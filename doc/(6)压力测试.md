# 一、前言

到这一章，项目基本上已经介绍完了，如果有什么不懂或者项目的不足之处，欢迎在评论区下留言，非常感谢。项目进行了适当的压力测试以及改进的一些思考。

# 二、压测

**Webbench是什么，介绍一下原理**
父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。

![在这里插入图片描述](https://ydlin.oss-cn-guangzhou.aliyuncs.com/blog-img/3b868291e2ee4e0aa067cbed2feee16a.png)

压力测试的参数：

```bash
webbench -c 10500 -t 5 http://127.0.0.1 
```

客户端数量10500， 运行测试的时间。

```php
webbench -c 1000 -t 60 http://192.168.80.157/phpinfo.php
每秒钟响应请求数：24525 pages/min，每秒钟传输数据量20794612 bytes/sec.
并发1000运行60秒后产生的TCP连接数12000多个,已经显示有87个连接failed了，说明超负荷了。
```

# 三、服务器的改进之处

(1) 服务器定时器的设计

定时器建立在双向链表上的

| 位置         | 添加 | 删除 |
| ------------ | ---- | ---- |
| 刚好在头节点 | O(1) | O(1) |
| 刚好在尾节点 | O(n) | O(1) |
| 平均         | O(n) | O(1) |

**Notes**

添加在为节点时间复杂度为O(n)，因为项目的逻辑是先从头遍历新定时器在链表的位置，如果位置恰好在最后，则插入的时间复杂度O(N)

a.在双向链表的基础上优化：

添加在尾节点的时间复杂度可以优化：在添加新的定时器的时候，**除了检测新定时器是否在小于头节点定时器的时间外，再先检测新定时器是否在大于尾节点定时器的时间，都不符合再使用常规插入。**

b.不使用双向链表，使用最小堆结构可以进行优化。

**最小堆优化？说一下时间复杂度和工作原理**

时间复杂度：

添加：`O(lgn)`

删除：`O(1)`

工作原理：

将所有定时器中超时时间最小的一个定时器的超时值作为alarm函数的定时值。这样，一旦定时任务处理函数tick()被调用，超时时间最小的定时器必然到期，我们就可以在tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个（堆），并将这段最小时间设置为下一次alarm函数的定时值。如此反复，就实现了较为精确的定时。



# 四、其他问题

### 大文件传输问题

发送数据数据调用`writev` 

小文件调用一次就可以将数据全部发送出去。

大文件，需要多次调用`writev`, 然而默认的函数调用不用自动偏移指针。

> writev以顺序iov[0]，iov[1]至iov[iovcnt-1]从缓冲区中聚集输出数据

iov[0]为存储报文状态行的缓冲区，iov[1]指向资源文件指针。

修改：

- 由于报文消息报头较小，第一次传输后，需要更新`m_iv[1]`.iov_base和iov_len，m_iv[0].iov_len置成0，只传输文件，不用传输响应消息头
- 每次传输后**都要更新下次传输的文件起始位置和长度**

补：

`write`和`writev` 的区别：

1. writev允许处理非连续的数据块。也就是说，缓冲区可以逐个单独分配，不用是一块连续的较大的地址空间。
2. writev 的I/O是“原子的”。例如，如果你执行一个writev操作，所有数据将在一个连续操作中被写入，不会被中断。
3. 如果使用write，则必须在以下两种情况下进行选择:使用memcpy(带来额外开销)将它们复制到一个内存块中，然后再执行一个write调用。
4. 进行三个独立的write调用(带来额外开销)。另外，来自其他进程的write调用可以分散在这些write之间(也就是整体上看不是原子操作)。

# 五、小结

此项目是基于Linux的**轻量级多线程Web服务器**，应用层实现了一个简单的HTTP服务器，利用**多路IO复用**，可以同时监听多个请求，使用线程池处理请求，**使用模拟proactor模式，主线程负责监听**，监听有事件之后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象放入队列。睡眠在**请求队列上的工作线程被唤醒进行处理**，使用**状态机解析HTTP请求报文**，实现**同步/异步日志系统**，记录服务器运行状态，并**对系统进行了压力测试**。

项目难点：

1、如何提高服务器的并发能力

2、由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程

3、多线程并发的情况下，保证线程的同步。

到这一部分基本上讲完了。

项目的代码：https://github.com/YDLinStars/LinuxWebServer

[传送门](https://github.com/YDLinStars/LinuxWebServer)

## 六、参考资料

- TCP/IP网络编程
- Linux高性能服务器编程---游双
- 社长的[WebServer](https://github.com/qinguoyi/TinyWebServer)